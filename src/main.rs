//! # MLS Artifact Sizing Experiment
//!
//! This program measures the size of various MLS (Messaging Layer Security) artifacts
//! generated by the `openmls` library. It is designed to analyze the impact of using
//! Post-Quantum Cryptography (PQC) signature schemes on artifact sizes compared to
//! classical schemes like Ed25519.
//!
//! The experiment systematically iterates through a predefined set of ciphersuites,
//! including both classical and PQC options, and performs the following MLS operations
//! for various group sizes:
//!
//! - **Key Package Generation**: Measures the size of a standalone `KeyPackage`.
//! - **Add Member**: Measures the size of the `Commit` and `Welcome` messages when a new member is added.
//! - **Self-Update**: Measures the size of a `Commit` message for a member updating their own leaf node.
//! - **Remove Member**: Measures the size of a `Commit` message when a member is removed.
//!
//! The impact of the `ratchet_tree_extension` on the `Add Member` operation is also measured.
//!
//! Results are written to a CSV file for further analysis.
//!
//! ## Usage
//!
//! The experiment can be configured via command-line arguments:
//!
//! ```sh
//! cargo run --release -- --output-file <path> --group-sizes <sizes>
//! ```
//!
//! - `--output-file`: Specifies the path for the output CSV file.
//! - `--group-sizes`: A comma-separated list of group sizes to measure.

use clap::Parser;
use openmls::prelude::{tls_codec::*, *};
use openmls::storage::OpenMlsProvider;
use openmls_basic_credential::SignatureKeyPair;
use openmls_pqc_crypto::OpenMlsPqcProvider;
use std::fs::File;

// Helper function to create a `CredentialWithKey` and the corresponding `SignatureKeyPair`.
fn generate_credential_with_key(
    identity: Vec<u8>,
    signature_algorithm: SignatureScheme,
    provider: &impl OpenMlsProvider,
) -> (CredentialWithKey, SignatureKeyPair) {
    let credential = BasicCredential::new(identity);
    let signature_keys =
        SignatureKeyPair::new(signature_algorithm).expect("Error generating key pair.");
    signature_keys
        .store(provider.storage())
        .expect("Error storing keys.");
    (
        CredentialWithKey {
            credential: credential.into(),
            signature_key: signature_keys.public().into(),
        },
        signature_keys,
    )
}

// Helper function to generate a `KeyPackageBundle`.
fn generate_key_package(
    ciphersuite: Ciphersuite,
    provider: &impl OpenMlsProvider,
    signer: &SignatureKeyPair,
    credential_with_key: CredentialWithKey,
) -> KeyPackageBundle {
    KeyPackage::builder()
        .build(ciphersuite, provider, signer, credential_with_key)
        .unwrap()
}

/// Represents a single measurement point, capturing the size of MLS artifacts for a specific operation.
#[derive(Debug)]
struct Measurement {
    operation: String,
    group_size: usize,
    ciphersuite: Ciphersuite,
    ratchet_tree_extension: bool,
    commit_size_bytes: usize,
    welcome_size_bytes: usize,
    key_package_size_bytes: usize,
    message_size_bytes: usize,
}

impl Measurement {
    /// Writes the measurement data as a record to a CSV file.
    fn write_to_csv(
        &self,
        writer: &mut csv::Writer<File>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        writer.write_record(&[
            self.operation.clone(),
            self.group_size.to_string(),
            self.commit_size_bytes.to_string(),
            self.welcome_size_bytes.to_string(),
            self.key_package_size_bytes.to_string(),
            self.message_size_bytes.to_string(),
            self.ratchet_tree_extension.to_string(),
            format!("{:?}", self.ciphersuite.signature_algorithm()),
        ])?;
        Ok(())
    }
}

/// Sets up an MLS group of a specified size with a given ciphersuite.
///
/// This function creates a group, adds members until it reaches the desired size,
/// and returns the group state and the creator's keypair.
fn build_group_to_size<P: OpenMlsProvider>(
    size: usize,
    ciphersuite: Ciphersuite,
    provider: &P,
    use_ratchet_tree_extension: bool,
) -> Result<(MlsGroup, SignatureKeyPair), Box<dyn std::error::Error>>
where
    P::StorageError: 'static,
{
    let config = MlsGroupCreateConfig::builder()
        .wire_format_policy(PURE_PLAINTEXT_WIRE_FORMAT_POLICY)
        .ciphersuite(ciphersuite)
        .use_ratchet_tree_extension(use_ratchet_tree_extension)
        .build();
    let (alice_credential, alice_signer) = generate_credential_with_key(
        b"Alice".to_vec(),
        ciphersuite.signature_algorithm(),
        provider,
    );
    let mut alice_group = MlsGroup::new(provider, &alice_signer, &config, alice_credential)?;
    if size > 1 {
        let kps: Vec<KeyPackage> = (2..=size)
            .map(|i| {
                let (cred, signer) = generate_credential_with_key(
                    format!("P{}", i).into_bytes(),
                    ciphersuite.signature_algorithm(),
                    provider,
                );
                generate_key_package(ciphersuite, provider, &signer, cred)
                    .key_package()
                    .clone()
            })
            .collect();
        alice_group.add_members(provider, &alice_signer, &kps)?;
        alice_group.merge_pending_commit(provider)?;
    }
    Ok((alice_group, alice_signer))
}

/// Measures the size of `Commit` and `Welcome` messages when adding a new member to groups of various sizes.
fn run_add_member_scaling_experiment<P: OpenMlsProvider>(
    writer: &mut csv::Writer<File>,
    ciphersuite: Ciphersuite,
    provider: &P,
    use_ratchet_tree_extension: bool,
    group_sizes_to_measure: &[usize],
) -> Result<(), Box<dyn std::error::Error>>
where
    P::StorageError: 'static,
{
    println!(
        "\n--- Running ADD Operation: Ciphersuite={:?} | RatchetTreeExtension={} ---",
        ciphersuite.signature_algorithm(),
        use_ratchet_tree_extension
    );
    for &size in group_sizes_to_measure {
        if size < 2 {
            continue;
        }
        // Build a group of size - 1 to measure the cost of adding the Nth member.
        let (mut alice_group, alice_signer) =
            build_group_to_size(size - 1, ciphersuite, provider, use_ratchet_tree_extension)?;
        let (cred, signer) = generate_credential_with_key(
            format!("P{}", size).into_bytes(),
            ciphersuite.signature_algorithm(),
            provider,
        );
        let kp_bundle = generate_key_package(ciphersuite, provider, &signer, cred);
        let (commit, welcome, _) =
            alice_group.add_members(provider, &alice_signer, &[kp_bundle.key_package().clone()])?;

        let measurement = Measurement {
            operation: "add".to_string(),
            group_size: size,
            ciphersuite,
            ratchet_tree_extension: use_ratchet_tree_extension,
            commit_size_bytes: commit.tls_serialized_len(),
            welcome_size_bytes: welcome.tls_serialized_len(),
            key_package_size_bytes: 0,
            message_size_bytes: 0,
        };
        println!(
            "  -> Measuring at group size: {}. Commit: {} B, Welcome: {} B",
            size, measurement.commit_size_bytes, measurement.welcome_size_bytes
        );
        measurement.write_to_csv(writer)?;
    }
    Ok(())
}

/// Measures the size of a `Commit` message for a self-update operation.
///
/// Note: The `ratchet_tree_extension` does not affect the size of a self-update commit.
fn run_self_update_scaling_experiment<P: OpenMlsProvider>(
    writer: &mut csv::Writer<File>,
    ciphersuite: Ciphersuite,
    provider: &P,
    group_sizes_to_measure: &[usize],
) -> Result<(), Box<dyn std::error::Error>>
where
    P::StorageError: 'static,
{
    println!(
        "\n--- Running SELF-UPDATE Operation: Ciphersuite={:?} ---",
        ciphersuite.signature_algorithm()
    );
    let mut results = Vec::new();
    for &size in group_sizes_to_measure {
        if size < 1 {
            continue;
        }
        let (mut alice_group, alice_signer) =
            build_group_to_size(size, ciphersuite, provider, false)?;
        let (commit_out, _, _) = alice_group
            .self_update(provider, &alice_signer, LeafNodeParameters::default())?
            .into_contents();
        let commit_size = commit_out.tls_serialized_len();
        results.push((size, commit_size));
        println!(
            "  -> Measuring at group size: {}. Commit: {} B",
            size, commit_size
        );
    }
    for &(group_size, commit_size) in &results {
        Measurement {
            operation: "self_update".to_string(),
            group_size,
            ciphersuite,
            ratchet_tree_extension: false, // Not applicable for self-update.
            commit_size_bytes: commit_size,
            welcome_size_bytes: 0,
            key_package_size_bytes: 0,
            message_size_bytes: 0,
        }
        .write_to_csv(writer)?;
    }
    Ok(())
}

/// Measures the size of a `Commit` message when removing a member.
///
/// Note: The `ratchet_tree_extension` does not affect the size of a remove commit.
fn run_remove_member_scaling_experiment<P: OpenMlsProvider>(
    writer: &mut csv::Writer<File>,
    ciphersuite: Ciphersuite,
    provider: &P,
    group_sizes_to_measure: &[usize],
) -> Result<(), Box<dyn std::error::Error>>
where
    P::StorageError: 'static,
{
    println!(
        "\n--- Running REMOVE Operation: Ciphersuite={:?} ---",
        ciphersuite.signature_algorithm()
    );
    let mut results = Vec::new();
    for &size in group_sizes_to_measure {
        if size < 2 {
            continue;
        }
        let (mut alice_group, alice_signer) =
            build_group_to_size(size, ciphersuite, provider, false)?;
        // Remove the last member added to the group.
        let (commit_out, _, _) = alice_group.remove_members(
            provider,
            &alice_signer,
            &[LeafNodeIndex::new((size - 1) as u32)],
        )?;
        let commit_size = commit_out.tls_serialized_len();
        results.push((size, commit_size));
        println!(
            "  -> Measuring at group size: {}. Commit: {} B",
            size, commit_size
        );
    }
    for &(group_size, commit_size) in &results {
        Measurement {
            operation: "remove".to_string(),
            group_size,
            ciphersuite,
            ratchet_tree_extension: false, // Not applicable for remove.
            commit_size_bytes: commit_size,
            welcome_size_bytes: 0,
            key_package_size_bytes: 0,
            message_size_bytes: 0,
        }
        .write_to_csv(writer)?;
    }
    Ok(())
}

// Measures the size of an application message.
//
// Note: The `ratchet_tree_extension` and group size does not affect the size of application messages.
fn run_application_message_size_experiment<P: OpenMlsProvider>(
    writer: &mut csv::Writer<File>,
    ciphersuite: Ciphersuite,
    provider: &P,
) -> Result<(), Box<dyn std::error::Error>>
where
    P::StorageError: 'static,
{
    println!(
        "\n--- Running APPLICATION MESSAGE Measurement: Ciphersuite={:?} ---",
        ciphersuite.signature_algorithm()
    );
    // SETUP: Create a group with the specified size.
    let (mut alice_group, alice_signer) = build_group_to_size(2, ciphersuite, provider, false)?;
    let message_payload = b"This is a test message.";
    // TIMED: The cost of deriving the key and encrypting the message.
    let application_message = alice_group
        .create_message(provider, &alice_signer, message_payload)
        .expect("Error creating application message.");
    let message_size = application_message.tls_serialized_len();
    println!(
        "  -> Measuring at group size: {}. Message Size: {} B",
        2, message_size
    );
    let measurement = Measurement {
        operation: "application_message".to_string(),
        group_size: 2,
        ciphersuite,
        ratchet_tree_extension: false,
        commit_size_bytes: 0,
        welcome_size_bytes: 0,
        message_size_bytes: message_size,
        key_package_size_bytes: 0,
    };
    measurement.write_to_csv(writer)?;
    Ok(())
}

/// Measures the size of a `KeyPackage` for a given ciphersuite.
fn run_key_package_size_experiment<P: OpenMlsProvider>(
    writer: &mut csv::Writer<File>,
    ciphersuite: Ciphersuite,
    provider: &P,
) -> Result<(), Box<dyn std::error::Error>>
where
    P::StorageError: 'static,
{
    println!(
        "\n--- Running KEY PACKAGE SIZE Measurement: Ciphersuite={:?} ---",
        ciphersuite.signature_algorithm()
    );
    let (credential, signer) = generate_credential_with_key(
        b"Test".to_vec(),
        ciphersuite.signature_algorithm(),
        provider,
    );
    let kp_bundle = generate_key_package(ciphersuite, provider, &signer, credential);
    let measurement = Measurement {
        operation: "key_package_generation".to_string(),
        group_size: 1, // Not applicable, but set to 1 for consistency.
        ciphersuite,
        ratchet_tree_extension: false, // Not applicable.
        commit_size_bytes: 0,
        welcome_size_bytes: 0,
        message_size_bytes: 0,
        key_package_size_bytes: kp_bundle.key_package().tls_serialized_len(),
    };
    println!(
        "  -> KeyPackage Size: {} B",
        measurement.key_package_size_bytes
    );
    measurement.write_to_csv(writer)?;
    Ok(())
}

/// Command-line arguments for the MLS artifact sizing tool.
#[derive(Parser, Debug)]
#[command(
    author,
    version,
    about,
    long_about = "A tool to measure MLS artifact sizes for various ciphersuites and group sizes."
)]
struct Args {
    /// Path to the output CSV file.
    #[arg(short, long, default_value = "mls_object_size_scaling.csv")]
    output_file: String,
    /// Comma-separated list of group sizes to measure.
    #[arg(
        long,
        value_delimiter = ',',
        default_value = "2,10,50,100,250,500,1000"
    )]
    group_sizes: Vec<usize>,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();
    let provider = &OpenMlsPqcProvider::default();

    // A selection of ciphersuites including classical and PQC signature schemes.
    let ciphersuites_to_test = vec![
        // Classical
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519,
        // NIST Level 1
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_MLDSA44,
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_SPHINCS_SHA_128F,
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_SPHINCS_SHA_128S,
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_FALCON_512,
        // NIST Level 3
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_MLDSA65,
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_SPHINCS_SHA_192F,
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_SPHINCS_SHA_192S,
        // NIST Level 5
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_MLDSA87,
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_SPHINCS_SHA_256F,
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_SPHINCS_SHA_256S,
        Ciphersuite::MLS_128_DHKEMX25519_AES128GCM_SHA256_FALCON_1024,
    ];

    let mut writer = csv::Writer::from_path(&args.output_file)?;
    // Write CSV header
    writer.write_record(&[
        "operation",
        "group_size",
        "commit_message_size_bytes",
        "welcome_message_size_bytes",
        "key_package_size_bytes",
        "message_size_bytes",
        "ratchet_tree_extension_enabled",
        "ciphersuite",
    ])?;

    // Iterate through each ciphersuite and run all experiments.
    for &ciphersuite in ciphersuites_to_test.iter() {
        run_key_package_size_experiment(&mut writer, ciphersuite, provider)?;

        // For 'add' operation, test with and without the ratchet tree extension.
        for &use_extension in [true, false].iter() {
            run_add_member_scaling_experiment(
                &mut writer,
                ciphersuite,
                provider,
                use_extension,
                &args.group_sizes,
            )?;
        }

        // For 'self-update' and 'remove', the ratchet tree extension is not relevant to size,
        // so we run a single experiment.
        run_self_update_scaling_experiment(&mut writer, ciphersuite, provider, &args.group_sizes)?;
        run_remove_member_scaling_experiment(
            &mut writer,
            ciphersuite,
            provider,
            &args.group_sizes,
        )?;
        // For 'application message' size, we run a single experiment.
        run_application_message_size_experiment(&mut writer, ciphersuite, provider)?;
    }

    writer.flush()?;
    println!(
        "\nâœ… All measurements complete. Results saved to '{}'.",
        args.output_file
    );
    Ok(())
}
